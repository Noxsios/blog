+++
title = "Adding Windows support to Zarf"
slug = "adding-windows-support-to-zarf"
date = 2022-10-04
draft = true

[taxonomies]
tags = ["zarf"]
+++

A quick dive into some issues making [`zarf`](https://github.com/defenseunicorns/zarf) Windows compatible.

<!-- more -->

## Setup Windows dev environment

1. Remote desktop into a Windows 11 machine on my network
2. Install deps w/ [`scoop`](https://scoop.sh/) _(its like brew for windows)_

    ```powershell
    scoop install git curl make go nodejs k9s kubectl kind gpg
    ```

3. Startup Docker w/ the [`WSL2 backend`](https://docs.docker.com/desktop/windows/wsl/)
4. Provision a fresh cluster w/

    ```powershell
    kind create cluster
    ```

5. Clone zarf w/ Github CLI

    ```powershell
    gh repo clone defenseunicorns/zarf
    cd zarf
    ```

6. Setup GPG Git signing - [Github docs](https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key)
7. Tell Git where to find GPG:

    ```powershell
    # replace <user> with your username
    git config --global gpg.program "C:\Users\<user>\scoop\apps\gpg\current\bin\gpg.exe"
    ```

8. Start developing

## Adding build target to Makefile

Adding a new build target to the [`Makefile`](https://github.com/defenseunicorns/zarf/blob/master/Makefile) was simple.

I was not looking to make the Makefile Windows compatible, just create a Windows build target.

Once the binary is built, the experience should be 1:1 on *nix, so there is little need to refactor the build system.

```makefile
...
ZARF_BIN := ./build/zarf
...
ifeq ($(OS),Windows_NT)
    ZARF_BIN := $(addsuffix -windows-amd64.exe,$(ZARF_BIN))
else
...
build-cli-windows-amd: build-injector-registry-amd build-ui
    GOOS=windows GOARCH=amd64 go build -ldflags="$(BUILD_ARGS)" -o build/zarf-windows-amd64.exe main.go
...
build-cli: build-cli-linux-amd build-cli-linux-arm build-cli-mac-intel build-cli-mac-apple build-cli-windows-amd ## Build the CLI
...
```

> at the time of writing this, I was only looking to get x86_64 Windows support, ARM is a future ask

## Fixing filepaths

Since Windows uses `\` as a path separator any code doing manual path joins/concatenation needed to be refactored.

> Modern Windows is pretty chill about file paths using `/`, but it is best to be safe and utilize Go's native OS handling

examples:

```go
// src/internal/helm/utils.go
import (
    ...
    "path/filepath"
    ...
)

// StandardName generates a predictable full path for a helm chart for Zarf
func StandardName(destination string, chart types.ZarfChart) string {
    return destination + "/" + chart.Name + "-" + chart.Version
}
// becomes
func StandardName(destination string, chart types.ZarfChart) string {
    return filepath.Join(destination, chart.Name+"-"+chart.Version)
}
```

```go
// src/internal/packager/validate/validate.go
import (
    ...
    "os"
    "path/filepath"
    "strings"
    ...
)
    ...
    // add a forward slash to end of path if it does not have one
    if !strings.HasSuffix(path, "/") {
        path = path + "/"
    }
    ...
    // becomes
    if !strings.HasSuffix(path, string(os.PathSeparator)) {
        path = filepath.Clean(path) + string(os.PathSeparator)
    }
```

## Troubleshooting `zarf init`

At this point compiling works just fine:

```powershell
$ make build-cli-windows-amd && ls build

    Directory: C:\bin\zarf\build

Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d----           10/4/2022  4:42 PM                ui
-a---           10/4/2022  4:42 PM       13119488 zarf-registry-amd64
-a---           10/4/2022  4:42 PM      101293056 zarf-windows-amd64.exe
```

> `&&` works because I am using PowerShell Version 7+

__But `zarf init` fails!__

```powershell
$ cd build
$ kind delete cluster && kind create cluster
$ .\zarf-windows-amd64.exe init -l=trace

# very long output omitted for sanity

panic: runtime error: index out of range [0] with length 0

goroutine 1 [running]:
github.com/defenseunicorns/zarf/src/internal/k8s.(*Tunnel).getAttachablePodForService(0xc00068e3f0)
        C:/bin/zarf/src/internal/k8s/tunnel.go:449 +0x18d
github.com/defenseunicorns/zarf/src/internal/k8s.(*Tunnel).getAttachablePodForResource(0xc00068e3f0)
        C:/bin/zarf/src/internal/k8s/tunnel.go:429 +0xaa
github.com/defenseunicorns/zarf/src/internal/k8s.(*Tunnel).establish(0xc00068e3f0)
        C:/bin/zarf/src/internal/k8s/tunnel.go:326 +0x445
github.com/defenseunicorns/zarf/src/internal/k8s.(*Tunnel).Connect(0xc00068e3f0, {0x7ff68c016fdf, 0x8}, 0x0)
        C:/bin/zarf/src/internal/k8s/tunnel.go:191 +0x39a
github.com/defenseunicorns/zarf/src/internal/packager.hasSeedImages(0xc0005ec1b0)
        C:/bin/zarf/src/internal/packager/injector.go:200 +0xd1
github.com/defenseunicorns/zarf/src/internal/packager.runInjectionMadness({{0xc000a8a390, 0x30}, {0xc00097f300, 0x3e}, {0xc00097f380, 0x3e}, {0xc00097f400, 0x3f}, {0xc00097f480, 0x3b}, ...})
        C:/bin/zarf/src/internal/packager/injector.go:104 +0x73f
github.com/defenseunicorns/zarf/src/internal/packager.deployComponents({{0xc000a8a390, 0x30}, {0xc00097f300, 0x3e}, {0xc00097f380, 0x3e}, {0xc00097f400, 0x3f}, {0xc00097f480, 0x3b}, ...}, ...)
        C:/bin/zarf/src/internal/packager/deploy.go:158 +0x2fb
github.com/defenseunicorns/zarf/src/internal/packager.Deploy()
        C:/bin/zarf/src/internal/packager/deploy.go:112 +0x8d8
github.com/defenseunicorns/zarf/src/cmd.glob..func5(0x7ff68b5dd880?, {0x7ff68c0025d6?, 0x1?, 0x1?})
        C:/bin/zarf/src/cmd/initialize.go:120 +0x725
github.com/spf13/cobra.(*Command).execute(0x7ff68b5dd880, {0xc000bc5a70, 0x1, 0x1})
        C:/Users/razzle/go/pkg/mod/github.com/spf13/cobra@v1.5.0/command.go:876 +0x67b
github.com/spf13/cobra.(*Command).ExecuteC(0x7ff68b5dbd00)
        C:/Users/razzle/go/pkg/mod/github.com/spf13/cobra@v1.5.0/command.go:990 +0x3bd
github.com/spf13/cobra.(*Command).Execute(...)
        C:/Users/razzle/go/pkg/mod/github.com/spf13/cobra@v1.5.0/command.go:918
github.com/defenseunicorns/zarf/src/cmd.Execute()
        C:/bin/zarf/src/cmd/root.go:49 +0x25
main.main()
        C:/bin/zarf/main.go:20 +0x6f
```

Super clear error message am I right?

After a few short hours of troubleshooting, I was able to trace the root of the issue to `src\internal\packager\injector.go`.

For some context, when zarf initializes it spins up an `injector` pod in the `zarf` namespace.  This pod carries out two stages.

There are two VolumeMounts created for this pod, `zarf-stage1` which is a collection of __ConfigMaps__, and `zarf-stage2` which is initialized as an __EmptyDir__ _(this distinciton is important later on)_.

### `init-injector`

In stage1 (run in an InitContainer), the cleverly designed Rust binary [`zarf-injector`](https://github.com/defenseunicorns/zarf/tree/master/src/injector/stage1) is mounted into the pod and used to create `/zarf-stage2/seed-image.tar`.

### `injector`

Ok, stage2, hype city.  In this stage the internal registry is populated using the Go binary `/zarf-stage2/zarf-registry`.

Looking at the logs in `injector`, this is where the core issue lies.

```text
$ kubectl describe pods/injector -n zarf | Select-String Message:

Message:      failed to create containerd task: failed to create shim task: 
OCI runtime create failed: runccreate failed: unable to start container 
process: exec: "/zarf-stage2/zarf-registry": permission denied: unknown
```

From this message, the issue is that there is a permission issue on `/zarf-stage2/zarf-registry`.

Swapping the container image to `ubuntu`, and changing `injector`'s startup command to `["ls", "-la"]`, I got these interesting results:

```text
# stage2's contents when run on mac
drwxrwxrwx 2 root root 4096 Oct 3 22:55 .
drwxr-xr-x 1 root root 4096 Oct 3 22:55 ..
-rw-r--r-- 1 root root 9278976 Oct 3 22:55 seed-image.tar
-rwx------ 1 root root 12582912 Oct 3 22:55 zarf-registry

# stage2's contents when run on windows
drwxrwxrwx 2 root root 4096 Oct 3 22:49 .
drwxr-xr-x 1 root root 4096 Oct 3 22:49 ..
-rw-rw-rw- 1 root root 9951232 Oct 3 22:48 seed-image.tar
-rw-rw-rw- 1 root root 13119488 Oct 3 22:48 zarf-registry
```

__so why the permissions mismatch?__

> __Answer__: differences between *nix file systems and Windows file system

### There is no `chmod +x` in Windows

Windows does not determine if a file is executable via a filesystem flag, it determines via file name.

Anything on `$PATH` that ends in `.exe` is an executable.  However, our Rust/Golang Linux compiled binaries __do not__.

So... during the interim stage, when our `zarf-init-amd64.tar.zst` is unpacked into a temporary directory...
__all files lose ability to be executed__.

> TODO: finish me
