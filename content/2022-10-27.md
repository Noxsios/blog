+++
title = "Part 3: Static Docker Registry in Rust"
slug = "static-docker-registry-in-rust-part-3"
date = 2022-10-27
draft = true

[taxonomies]
tags = ["rust","zarf","docker-registry"]
+++

Part 3 of a multi-part series on writing a static Docker registry in Rust.

<!-- more -->

## Pulling the Manifest

Per the API spec, this route looks like:

```text
GET /v2/<name>/manifests/<reference>
```

where `name` is the name of the image (statically `registry` in this case), and `reference` is the tag of the image (in this case we dont care what `reference` is, we will only be serving one image for every reference).

Checking this endpoint with cURL:

```bash
$ docker tag registry:2.8.1 localhost:666/registry:2.8.1
$ docker push localhost:666/registry:2.8.1

$ curl localhost:666/v2/registry/manifests/2.8.1

# truncated example
{
   "name": <name>,
   "tag": <tag>,
   "fsLayers": [
      {
         "blobSum": <digest>
      },
      ...
    ]
   ],
   "history": <v1 images>,
   "signature": <JWS>
}
```

By default, the Docker registry is going to provide a v1 manifest. We can force it to provide a v2 manifest by setting the `Accept` header to `application/vnd.docker.distribution.manifest.v2+json`:

```bash
$ curl localhost:666/v2/registry/manifests/2.8.1 -H "Accept: application/vnd.docker.distribution.manifest.v2+json"

# truncated v2 example
{
  "schemaVersion": 2,
  "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
  "config": {
    "mediaType": "application/vnd.docker.container.image.v1+json",
    "size": <size>,
    "digest": <digest>
  },
  "layers": [
    {
      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
      "size": <int>,
      "digest": <digest>
    },
    ...
  ]
}
```

v1 is basically dead, and I really didn't feel like supporting it, so for every request to `/v2/registry/manifests/<reference>`, we will return a v2 manifest.

But wait, we dont have a v2 manifest!  We have a [Crane tarball](https://github.com/google/go-containerregistry/blob/main/pkg/v1/tarball/README.md) (`zarf` uses Crane under the hood for pulling and storing images).

```bash
$ mkdir -p mnt/init
$ mkdir -p mnt/registry-rust

# unpack init package into mnt
$ tar --use-compress-program=unzstd -xvf zarf-init-{ARCH}-{VERSION}.tar.zst -C mnt/init

# unpack seed-image.tar into mnt/registry-rust
$ tar -xvf mnt/init/seed-image.tar -C mnt/registry-rust

$ ls -l mnt/registry-rust
# if this output looks weird to you, thats because I am using `exa` instead of `ls`

Permissions Size User   Date Modified Name
.rw-r--r--   369 razzle 31 Dec  1969  03bbf04a79081d9f1f6cca63e9480201759523dd8129c33a90fa103740dada3b.tar.gz
.rw-r--r--  2.7M razzle 31 Dec  1969  9b18e9b68314027565b90ff6189d65942c0f7986da80df008b8431276885218e.tar.gz
.rw-r--r--   214 razzle 31 Dec  1969  27c60cee15e894d66ba4a00568a27b094f725197640e58d81129d9241a13b2ee.tar.gz
.rw-r--r--  5.5M razzle 31 Dec  1969  cb556f39845e9506e3500b5bb5e74c696935b5b3d729bb5c7121ba9a420ded8c.tar.gz
.rw-r--r--  285k razzle 31 Dec  1969  d32db5db73116c723916b5df8f4ecc82d84f63f631c631d3fb81997d2fac11e9.tar.gz
.rw-r--r--   497 razzle 31 Dec  1969  manifest.json
.rw-r--r--  4.1k razzle 31 Dec  1969  sha256:02bcf88391173d5ffd5cc5542c0d3335124607bfe16f11d07bbbfcafd2348059

# and the manifest.json
$ cat mnt/registry-rust/manifest.json | jq

[
  {
    "Config": "sha256:02bcf88391173d5ffd5cc5542c0d3335124607bfe16f11d07bbbfcafd2348059",
    "RepoTags": [
      "registry:2.8.1"
    ],
    "Layers": [
      "9b18e9b68314027565b90ff6189d65942c0f7986da80df008b8431276885218e.tar.gz",
      "d32db5db73116c723916b5df8f4ecc82d84f63f631c631d3fb81997d2fac11e9.tar.gz",
      "cb556f39845e9506e3500b5bb5e74c696935b5b3d729bb5c7121ba9a420ded8c.tar.gz",
      "03bbf04a79081d9f1f6cca63e9480201759523dd8129c33a90fa103740dada3b.tar.gz",
      "27c60cee15e894d66ba4a00568a27b094f725197640e58d81129d9241a13b2ee.tar.gz"
    ]
  }
]
```

> What Now Airman?

## Translating Crane to v2

So now we need to write a translation layer between this Crane manifest to a v2 manifest.  This is where the [`oci-spec`](https://github.com/containers/oci-spec-rs), and [`serde`](https://crates.io/crates/serde) crates comes in.

> "Serde is a framework for **ser**ializing and **de**serializing Rust data structures efficiently and generically." - [serde.rs](https://serde.rs/)

First we read the Crane manifest into a `serde_json::Value`

```rust
use serde::{Deserialize, Serialize};

let mut file = File::open(root.join("manifest.json")).unwrap();
let mut data = String::new();
file.read_to_string(&mut data).unwrap();

#[derive(Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")] // <-- one really cool feature of serde is that it can rename fields to different casing, as rust prefers snake_case
struct CraneManifest {
    config: String,
    repo_tags: Vec<String>,
    layers: Vec<String>,
}

let crane_manifest: Vec<CraneManifest> = serde_json::from_str(&data).expect("manifest.json was not of struct CraneManifest");
```

THen we can use the `oci-spec` crate to build a v2 manifest.

```rust
use oci_spec::image::{
    Descriptor, DescriptorBuilder, ImageManifestBuilder, MediaType, SCHEMA_VERSION,
};

fn get_file_size(path: &PathBuf) -> i64 {
  let metadata = std::fs::metadata(path).unwrap();
  metadata.len() as i64
}

let config_digest = root.join(crane_manifest[0].config.clone());

let config = DescriptorBuilder::default()
    .media_type(MediaType::ImageConfig)
    .size(get_file_size(&config_digest))
    .digest(crane_manifest[0].config.clone())
    .build()
    .expect("build config descriptor");

let layers: Vec<Descriptor> = crane_manifest[0].layers.iter().map(|layer| {
    let digest = root.join(layer);
    // the crane manifest + storage has the layers keep their .tar.gz extension, but the v2 manifest does not
    let full_digest = format!("sha256:{}", layer.to_string().strip_suffix(".tar.gz").unwrap());

    const ROOTF_DIFF_TAR_GZIP: &str = "application/vnd.docker.image.rootfs.diff.tar.gzip";

    DescriptorBuilder::default()
        .media_type(MediaType::Other(ROOTF_DIFF_TAR_GZIP.to_string()))
        .size(get_file_size(&digest))
        .digest(full_digest)
        .build()
        .expect("build layer")
}).collect();

let manifest = ImageManifestBuilder::default()
    .schema_version(SCHEMA_VERSION)
    .media_type(MediaType::Other("application/vnd.docker.distribution.manifest.v2+json".to_string()))
    .config(config)
    .layers(layers)
    .build()
    .expect("build image manifest");
```

And now we can respond to the client with the v2 manifest.

> As stated above, the default behavior for a registry is to provide the v1 manifest unless an Accept header is provided.
> In this case, we are only providing the v2 manifest (can't wait to discover edge cases lol)

```rust
(GET) (/v2/registry/manifests/{_tag :String}) => {
  // since we are only ever serving a single version of the `registry` image, we can ignore the tag parameter

  // all of the above code here

  let response = Response::json(&manifest)
                  .with_unique_header("Content-Type", "application/vnd.docker.distribution.manifest.v2+json")
                  .with_additional_header("Docker-Content-Digest", manifest.config().digest().to_string())
                  .with_additional_header("Etag", manifest.config().digest().to_string())
                  .with_additional_header("Docker-Distribution-Api-Version", "registry/2.0");
  response
  // rust implicity returns the last line of a function
}
```

Lets check it:

```bash
$ curl localhost:8080/v2/registry/manifests/2.8.1 | jq

{
  "schemaVersion": 2,
  "mediaType": "application/vnd.docker.distribution.manifest.v2+json",
  "config": {
    "mediaType": "application/vnd.docker.container.image.v1+json",
    "size": 4139,
    "digest": "sha256:02bcf88391173d5ffd5cc5542c0d3335124607bfe16f11d07bbbfcafd2348059"
  },
  "layers": [
    {
      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
      "size": 2707663,
      "digest": "sha256:9b18e9b68314027565b90ff6189d65942c0f7986da80df008b8431276885218e"
    },
    {
      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
      "size": 284532,
      "digest": "sha256:d32db5db73116c723916b5df8f4ecc82d84f63f631c631d3fb81997d2fac11e9"
    },
    {
      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
      "size": 5544450,
      "digest": "sha256:cb556f39845e9506e3500b5bb5e74c696935b5b3d729bb5c7121ba9a420ded8c"
    },
    {
      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
      "size": 369,
      "digest": "sha256:03bbf04a79081d9f1f6cca63e9480201759523dd8129c33a90fa103740dada3b"
    },
    {
      "mediaType": "application/vnd.docker.image.rootfs.diff.tar.gzip",
      "size": 214,
      "digest": "sha256:27c60cee15e894d66ba4a00568a27b094f725197640e58d81129d9241a13b2ee"
    }
  ]
}
```

## Serving Layers

Ok, now how do I serve the blobs? This part was actually pretty easy, the only hiccup was some basic error handling (I am still very new to Rust).

```rust
(GET) (/v2/registry/blobs/{digest :String}) => {
    let mut path = root.join(digest.clone());

    match path.try_exists() {
        Ok(true) => {
            // means they queried the config json
        },
        _ => {
            // means they queried a layer
            path = root.join(digest.strip_prefix("sha256:").unwrap());
            path.set_extension("tar.gz");
        }
    }
    let file = File::open(&path).unwrap();
    Response::from_file("application/octet-stream", file)
        .with_additional_header("Docker-Content-Digest", digest.clone())
        .with_additional_header("Etag", digest)
        .with_additional_header("Docker-Distribution-Api-Version", "registry/2.0")
        .with_additional_header("Cache-Control", "max-age=31536000")
},
```

Lets check it:

```bash
$ curl localhost:8000/v2/registry/blobs/sha256:27c60cee15e894d66ba4a00568a27b094f725197640e58d81129d9241a13b2ee -o layer
# the above command will save the layer to a file called `layer`

# lets verify the sha256sum
$ sha256sum layer
27c60cee15e894d66ba4a00568a27b094f725197640e58d81129d9241a13b2ee  layer

$ rm layer
```

From an API standpoint everything looks solid! In the next part I will test out the registry with Docker and see how it goes.
