+++
title = "Consider the Source"
slug = "consider-the-source"
date = 2023-09-24
draft = true

[taxonomies]
tags = ["zarf","design-patterns"]
+++

> tldr; Standardizing the loading process of Zarf packages.

<!-- more -->

## Overview

Zarf natively supports creating the following package sources:

- **Local Tarball** (`.tar` and `.tar.zst`)
  - Via `zarf package create <dir> -o <dir>`, whether or not the resulting tarball is compressed is determined by `metadata.uncompressed` in `zarf.yaml`
- **Split Tarball** (`.part...`)
  - Via `zarf package create <dir> --max-package-size <size> -o <dir>` (or interactively if `--confirm` is not passed)
- **OCI** (`oci://`)
  - Via `zarf package publish <source> oci://` or `zarf package create <dir> -o oci://...`
- **In-cluster (Deployed)**
  - Post `zarf package deploy <source>` the package is show in `zarf package list`

_However_, the current loading abilities of Zarf have been inconsistent depending upon the action specified. For example:

- Split tarball packages could be created, deployed, but not inspected or removed
- In-cluster packages could be removed (by name), but not inspected
- HTTPs URLs could be deployed, but not inspected, or removed
- etc...

And so I was tasked with standardizing the loading process of Zarf packages so that:

- `deploy`
- `inspect`
- `remove`
- `publish`
- `pull`
- `mirror-resources`

would all work with all of the above sources.

## The PackageSource Interface

To accomplish this, I turned towards behavior driven development (BDD) and creating a standard interface for all package sources to implement.

In Go, interfaces are satisfied implicitly. This means that if a type has the same method signatures as an interface, it is considered to implement that interface. For package sources, this means that any type that implements the `PackageSource` interface can be used as a package source.

```go
// PackageSource is an interface for package sources.
//
// While this interface defines three functions, LoadPackage, LoadPackageMetadata, and Collect; only one of them should be used within a packager function.
//
// These functions currently do not promise repeatability due to the side effect nature of loading a package.
type PackageSource interface {
    // LoadPackage loads a package from a source.
    //
    // For the default sources included in Zarf, package integrity (checksums, signatures, etc.) is validated during this function
    // and expects the package structure to follow the default Zarf package structure.
    //
    // If your package does not follow the default Zarf package structure, you will need to implement your own source.
    LoadPackage(*layout.PackagePaths) error
    // LoadPackageMetadata loads a package's metadata from a source.
    //
    // This function follows the same principles as LoadPackage, with a few exceptions:
    //
    // - Package integrity validation will display a warning instead of returning an error if
    //   the package is signed but no public key is provided. This is to allow for the inspection and removal of packages
    //   that are signed but the user does not have the public key for.
    LoadPackageMetadata(dst *layout.PackagePaths, wantSBOM bool, skipValidation bool) error

    // Collect relocates a package from its source to a tarball in a given destination directory.
    Collect(destinationDirectory string) (tarball string, err error)
}
```

I went through a ton of iterations on the naming, inputs and outputs on each of the above functions, but the end result is that each function is responsible for a single task:

- `LoadPackage` and `LoadPackageMetadata`  load a package from a source, whilst populating the `PackagePaths` struct with "loaded" paths
- `Collect` transforms the source into a tarball, and returns the path to the tarball

Signature validation and package integrity are also performed _within_ each implementation. This gives library users of Zarf full control over how they want to handle signatures and package integrity.

## Result

The result of creating implementations for each source is such that any source can be used for any action. For example:

```bash
# inspecting an in-cluster package
$ zarf package inspect init

# removing an OCI package 
# (ðŸ¦„ is an alias to `ghcr.io/defenseunicorns/packages`, just `defenseunicorns` works as well)
$ zarf package remove oci://ðŸ¦„/init:v0.29.2-amd64

# pulling an HTTPS package
$ zarf package pull https://pkg.zarf.dev/hello-world

# deploying a split tarball package
$ zarf package deploy ./zarf-package-multi-part-arm64.tar.zst.part000

# publishing OCI to OCI
# this uses the same code that bundle uses, so layers never touch your disk!
# it pipes the GET request from the source to the PUT request to the destination
$ zarf package publish oci://ðŸ¦„/init:v0.29.2-amd64 oci://docker.io/waynestarr
```

There are a ton more tweaks and changes under the hood to ensure feature parity of each source, but the end result is that Zarf is now more consistent and predictable when it comes to loading packages.
